// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver/receivertest"
	"go.uber.org/zap"
	"go.uber.org/zap/zaptest/observer"
)

func TestDefaultMetrics(t *testing.T) {
	start := pcommon.Timestamp(1_000_000_000)
	ts := pcommon.Timestamp(1_000_001_000)
	mb := NewMetricsBuilder(DefaultMetricsSettings(), receivertest.NewNopCreateSettings(), WithStartTime(start))
	enabledMetrics := make(map[string]bool)

	enabledMetrics["aerospike.namespace.disk.available"] = true
	mb.RecordAerospikeNamespaceDiskAvailableDataPoint(ts, "1")

	enabledMetrics["aerospike.namespace.geojson.region_query_cells"] = true
	mb.RecordAerospikeNamespaceGeojsonRegionQueryCellsDataPoint(ts, "1")

	enabledMetrics["aerospike.namespace.geojson.region_query_false_positive"] = true
	mb.RecordAerospikeNamespaceGeojsonRegionQueryFalsePositiveDataPoint(ts, "1")

	enabledMetrics["aerospike.namespace.geojson.region_query_points"] = true
	mb.RecordAerospikeNamespaceGeojsonRegionQueryPointsDataPoint(ts, "1")

	enabledMetrics["aerospike.namespace.geojson.region_query_requests"] = true
	mb.RecordAerospikeNamespaceGeojsonRegionQueryRequestsDataPoint(ts, "1")

	enabledMetrics["aerospike.namespace.memory.free"] = true
	mb.RecordAerospikeNamespaceMemoryFreeDataPoint(ts, "1")

	enabledMetrics["aerospike.namespace.memory.usage"] = true
	mb.RecordAerospikeNamespaceMemoryUsageDataPoint(ts, "1", AttributeNamespaceComponent(1))

	enabledMetrics["aerospike.namespace.query.count"] = true
	mb.RecordAerospikeNamespaceQueryCountDataPoint(ts, "1", AttributeQueryType(1), AttributeIndexType(1), AttributeQueryResult(1))

	enabledMetrics["aerospike.namespace.scan.count"] = true
	mb.RecordAerospikeNamespaceScanCountDataPoint(ts, "1", AttributeScanType(1), AttributeScanResult(1))

	enabledMetrics["aerospike.namespace.transaction.count"] = true
	mb.RecordAerospikeNamespaceTransactionCountDataPoint(ts, "1", AttributeTransactionType(1), AttributeTransactionResult(1))

	enabledMetrics["aerospike.node.connection.count"] = true
	mb.RecordAerospikeNodeConnectionCountDataPoint(ts, "1", AttributeConnectionType(1), AttributeConnectionOp(1))

	enabledMetrics["aerospike.node.connection.open"] = true
	mb.RecordAerospikeNodeConnectionOpenDataPoint(ts, "1", AttributeConnectionType(1))

	enabledMetrics["aerospike.node.memory.free"] = true
	mb.RecordAerospikeNodeMemoryFreeDataPoint(ts, "1")

	enabledMetrics["aerospike.node.query.tracked"] = true
	mb.RecordAerospikeNodeQueryTrackedDataPoint(ts, "1")

	metrics := mb.Emit()

	assert.Equal(t, 1, metrics.ResourceMetrics().Len())
	sm := metrics.ResourceMetrics().At(0).ScopeMetrics()
	assert.Equal(t, 1, sm.Len())
	ms := sm.At(0).Metrics()
	assert.Equal(t, len(enabledMetrics), ms.Len())
	seenMetrics := make(map[string]bool)
	for i := 0; i < ms.Len(); i++ {
		assert.True(t, enabledMetrics[ms.At(i).Name()])
		seenMetrics[ms.At(i).Name()] = true
	}
	assert.Equal(t, len(enabledMetrics), len(seenMetrics))
}

func TestAllMetrics(t *testing.T) {
	start := pcommon.Timestamp(1_000_000_000)
	ts := pcommon.Timestamp(1_000_001_000)
	metricsSettings := MetricsSettings{
		AerospikeNamespaceDiskAvailable:                   MetricSettings{Enabled: true},
		AerospikeNamespaceGeojsonRegionQueryCells:         MetricSettings{Enabled: true},
		AerospikeNamespaceGeojsonRegionQueryFalsePositive: MetricSettings{Enabled: true},
		AerospikeNamespaceGeojsonRegionQueryPoints:        MetricSettings{Enabled: true},
		AerospikeNamespaceGeojsonRegionQueryRequests:      MetricSettings{Enabled: true},
		AerospikeNamespaceMemoryFree:                      MetricSettings{Enabled: true},
		AerospikeNamespaceMemoryUsage:                     MetricSettings{Enabled: true},
		AerospikeNamespaceQueryCount:                      MetricSettings{Enabled: true},
		AerospikeNamespaceScanCount:                       MetricSettings{Enabled: true},
		AerospikeNamespaceTransactionCount:                MetricSettings{Enabled: true},
		AerospikeNodeConnectionCount:                      MetricSettings{Enabled: true},
		AerospikeNodeConnectionOpen:                       MetricSettings{Enabled: true},
		AerospikeNodeMemoryFree:                           MetricSettings{Enabled: true},
		AerospikeNodeQueryTracked:                         MetricSettings{Enabled: true},
	}
	observedZapCore, observedLogs := observer.New(zap.WarnLevel)
	settings := receivertest.NewNopCreateSettings()
	settings.Logger = zap.New(observedZapCore)
	mb := NewMetricsBuilder(metricsSettings, settings, WithStartTime(start))

	assert.Equal(t, 0, observedLogs.Len())

	mb.RecordAerospikeNamespaceDiskAvailableDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryCellsDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryFalsePositiveDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryPointsDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryRequestsDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceMemoryFreeDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceMemoryUsageDataPoint(ts, "1", AttributeNamespaceComponent(1))
	mb.RecordAerospikeNamespaceQueryCountDataPoint(ts, "1", AttributeQueryType(1), AttributeIndexType(1), AttributeQueryResult(1))
	mb.RecordAerospikeNamespaceScanCountDataPoint(ts, "1", AttributeScanType(1), AttributeScanResult(1))
	mb.RecordAerospikeNamespaceTransactionCountDataPoint(ts, "1", AttributeTransactionType(1), AttributeTransactionResult(1))
	mb.RecordAerospikeNodeConnectionCountDataPoint(ts, "1", AttributeConnectionType(1), AttributeConnectionOp(1))
	mb.RecordAerospikeNodeConnectionOpenDataPoint(ts, "1", AttributeConnectionType(1))
	mb.RecordAerospikeNodeMemoryFreeDataPoint(ts, "1")
	mb.RecordAerospikeNodeQueryTrackedDataPoint(ts, "1")

	metrics := mb.Emit(WithAerospikeNamespace("attr-val"), WithAerospikeNodeName("attr-val"))

	assert.Equal(t, 1, metrics.ResourceMetrics().Len())
	rm := metrics.ResourceMetrics().At(0)
	attrCount := 0
	attrCount++
	attrVal, ok := rm.Resource().Attributes().Get("aerospike.namespace")
	assert.True(t, ok)
	assert.EqualValues(t, "attr-val", attrVal.Str())
	attrCount++
	attrVal, ok = rm.Resource().Attributes().Get("aerospike.node.name")
	assert.True(t, ok)
	assert.EqualValues(t, "attr-val", attrVal.Str())
	assert.Equal(t, attrCount, rm.Resource().Attributes().Len())

	assert.Equal(t, 1, rm.ScopeMetrics().Len())
	ms := rm.ScopeMetrics().At(0).Metrics()
	allMetricsCount := reflect.TypeOf(MetricsSettings{}).NumField()
	assert.Equal(t, allMetricsCount, ms.Len())
	validatedMetrics := make(map[string]struct{})
	for i := 0; i < ms.Len(); i++ {
		switch ms.At(i).Name() {
		case "aerospike.namespace.disk.available":
			assert.Equal(t, pmetric.MetricTypeGauge, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Gauge().DataPoints().Len())
			assert.Equal(t, "Minimum percentage of contiguous disk space free to the namespace across all devices", ms.At(i).Description())
			assert.Equal(t, "%", ms.At(i).Unit())
			dp := ms.At(i).Gauge().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.namespace.disk.available"] = struct{}{}
		case "aerospike.namespace.geojson.region_query_cells":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of cell coverings for query region queried", ms.At(i).Description())
			assert.Equal(t, "{cells}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.namespace.geojson.region_query_cells"] = struct{}{}
		case "aerospike.namespace.geojson.region_query_false_positive":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of points outside the region.", ms.At(i).Description())
			assert.Equal(t, "{points}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.namespace.geojson.region_query_false_positive"] = struct{}{}
		case "aerospike.namespace.geojson.region_query_points":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of points within the region.", ms.At(i).Description())
			assert.Equal(t, "{points}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.namespace.geojson.region_query_points"] = struct{}{}
		case "aerospike.namespace.geojson.region_query_requests":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of geojson queries on the system since the uptime of the node.", ms.At(i).Description())
			assert.Equal(t, "{queries}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.namespace.geojson.region_query_requests"] = struct{}{}
		case "aerospike.namespace.memory.free":
			assert.Equal(t, pmetric.MetricTypeGauge, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Gauge().DataPoints().Len())
			assert.Equal(t, "Percentage of the namespace's memory which is still free", ms.At(i).Description())
			assert.Equal(t, "%", ms.At(i).Unit())
			dp := ms.At(i).Gauge().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.namespace.memory.free"] = struct{}{}
		case "aerospike.namespace.memory.usage":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Memory currently used by each component of the namespace", ms.At(i).Description())
			assert.Equal(t, "By", ms.At(i).Unit())
			assert.Equal(t, false, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			attrVal, ok := dp.Attributes().Get("component")
			assert.True(t, ok)
			assert.Equal(t, "data", attrVal.Str())
			validatedMetrics["aerospike.namespace.memory.usage"] = struct{}{}
		case "aerospike.namespace.query.count":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of query operations performed on the namespace", ms.At(i).Description())
			assert.Equal(t, "{queries}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			attrVal, ok := dp.Attributes().Get("type")
			assert.True(t, ok)
			assert.Equal(t, "aggregation", attrVal.Str())
			attrVal, ok = dp.Attributes().Get("index")
			assert.True(t, ok)
			assert.Equal(t, "primary", attrVal.Str())
			attrVal, ok = dp.Attributes().Get("result")
			assert.True(t, ok)
			assert.Equal(t, "abort", attrVal.Str())
			validatedMetrics["aerospike.namespace.query.count"] = struct{}{}
		case "aerospike.namespace.scan.count":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of scan operations performed on the namespace", ms.At(i).Description())
			assert.Equal(t, "{scans}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			attrVal, ok := dp.Attributes().Get("type")
			assert.True(t, ok)
			assert.Equal(t, "aggregation", attrVal.Str())
			attrVal, ok = dp.Attributes().Get("result")
			assert.True(t, ok)
			assert.Equal(t, "abort", attrVal.Str())
			validatedMetrics["aerospike.namespace.scan.count"] = struct{}{}
		case "aerospike.namespace.transaction.count":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of transactions performed on the namespace", ms.At(i).Description())
			assert.Equal(t, "{transactions}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			attrVal, ok := dp.Attributes().Get("type")
			assert.True(t, ok)
			assert.Equal(t, "delete", attrVal.Str())
			attrVal, ok = dp.Attributes().Get("result")
			assert.True(t, ok)
			assert.Equal(t, "error", attrVal.Str())
			validatedMetrics["aerospike.namespace.transaction.count"] = struct{}{}
		case "aerospike.node.connection.count":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of connections opened and closed to the node", ms.At(i).Description())
			assert.Equal(t, "{connections}", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			attrVal, ok := dp.Attributes().Get("type")
			assert.True(t, ok)
			assert.Equal(t, "client", attrVal.Str())
			attrVal, ok = dp.Attributes().Get("operation")
			assert.True(t, ok)
			assert.Equal(t, "close", attrVal.Str())
			validatedMetrics["aerospike.node.connection.count"] = struct{}{}
		case "aerospike.node.connection.open":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Current number of open connections to the node", ms.At(i).Description())
			assert.Equal(t, "{connections}", ms.At(i).Unit())
			assert.Equal(t, false, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			attrVal, ok := dp.Attributes().Get("type")
			assert.True(t, ok)
			assert.Equal(t, "client", attrVal.Str())
			validatedMetrics["aerospike.node.connection.open"] = struct{}{}
		case "aerospike.node.memory.free":
			assert.Equal(t, pmetric.MetricTypeGauge, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Gauge().DataPoints().Len())
			assert.Equal(t, "Percentage of the node's memory which is still free", ms.At(i).Description())
			assert.Equal(t, "%", ms.At(i).Unit())
			dp := ms.At(i).Gauge().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.node.memory.free"] = struct{}{}
		case "aerospike.node.query.tracked":
			assert.Equal(t, pmetric.MetricTypeSum, ms.At(i).Type())
			assert.Equal(t, 1, ms.At(i).Sum().DataPoints().Len())
			assert.Equal(t, "Number of queries tracked by the system.", ms.At(i).Description())
			assert.Equal(t, "", ms.At(i).Unit())
			assert.Equal(t, true, ms.At(i).Sum().IsMonotonic())
			assert.Equal(t, pmetric.AggregationTemporalityCumulative, ms.At(i).Sum().AggregationTemporality())
			dp := ms.At(i).Sum().DataPoints().At(0)
			assert.Equal(t, start, dp.StartTimestamp())
			assert.Equal(t, ts, dp.Timestamp())
			assert.Equal(t, pmetric.NumberDataPointValueTypeInt, dp.ValueType())
			assert.Equal(t, int64(1), dp.IntValue())
			validatedMetrics["aerospike.node.query.tracked"] = struct{}{}
		}
	}
	assert.Equal(t, allMetricsCount, len(validatedMetrics))
}

func TestNoMetrics(t *testing.T) {
	start := pcommon.Timestamp(1_000_000_000)
	ts := pcommon.Timestamp(1_000_001_000)
	metricsSettings := MetricsSettings{
		AerospikeNamespaceDiskAvailable:                   MetricSettings{Enabled: false},
		AerospikeNamespaceGeojsonRegionQueryCells:         MetricSettings{Enabled: false},
		AerospikeNamespaceGeojsonRegionQueryFalsePositive: MetricSettings{Enabled: false},
		AerospikeNamespaceGeojsonRegionQueryPoints:        MetricSettings{Enabled: false},
		AerospikeNamespaceGeojsonRegionQueryRequests:      MetricSettings{Enabled: false},
		AerospikeNamespaceMemoryFree:                      MetricSettings{Enabled: false},
		AerospikeNamespaceMemoryUsage:                     MetricSettings{Enabled: false},
		AerospikeNamespaceQueryCount:                      MetricSettings{Enabled: false},
		AerospikeNamespaceScanCount:                       MetricSettings{Enabled: false},
		AerospikeNamespaceTransactionCount:                MetricSettings{Enabled: false},
		AerospikeNodeConnectionCount:                      MetricSettings{Enabled: false},
		AerospikeNodeConnectionOpen:                       MetricSettings{Enabled: false},
		AerospikeNodeMemoryFree:                           MetricSettings{Enabled: false},
		AerospikeNodeQueryTracked:                         MetricSettings{Enabled: false},
	}
	observedZapCore, observedLogs := observer.New(zap.WarnLevel)
	settings := receivertest.NewNopCreateSettings()
	settings.Logger = zap.New(observedZapCore)
	mb := NewMetricsBuilder(metricsSettings, settings, WithStartTime(start))

	assert.Equal(t, 0, observedLogs.Len())
	mb.RecordAerospikeNamespaceDiskAvailableDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryCellsDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryFalsePositiveDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryPointsDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceGeojsonRegionQueryRequestsDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceMemoryFreeDataPoint(ts, "1")
	mb.RecordAerospikeNamespaceMemoryUsageDataPoint(ts, "1", AttributeNamespaceComponent(1))
	mb.RecordAerospikeNamespaceQueryCountDataPoint(ts, "1", AttributeQueryType(1), AttributeIndexType(1), AttributeQueryResult(1))
	mb.RecordAerospikeNamespaceScanCountDataPoint(ts, "1", AttributeScanType(1), AttributeScanResult(1))
	mb.RecordAerospikeNamespaceTransactionCountDataPoint(ts, "1", AttributeTransactionType(1), AttributeTransactionResult(1))
	mb.RecordAerospikeNodeConnectionCountDataPoint(ts, "1", AttributeConnectionType(1), AttributeConnectionOp(1))
	mb.RecordAerospikeNodeConnectionOpenDataPoint(ts, "1", AttributeConnectionType(1))
	mb.RecordAerospikeNodeMemoryFreeDataPoint(ts, "1")
	mb.RecordAerospikeNodeQueryTrackedDataPoint(ts, "1")

	metrics := mb.Emit()

	assert.Equal(t, 0, metrics.ResourceMetrics().Len())
}
